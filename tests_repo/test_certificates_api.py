import configparser
import os
import sqlite3
import subprocess
import sys
import time
import uuid
from pathlib import Path

import pytest
import requests


ROOT_DIR = Path(__file__).resolve().parents[1]
SCRIPTS_DIR = ROOT_DIR / "tests" / "scripts"
EDITION = (os.getenv("PIKACHU_EDITION") or "community").strip().lower()


def _is_enterprise():
    return EDITION == "enterprise"


@pytest.fixture(scope="session", autouse=True)
def cleanup_api_artifacts():
    """
    After API tests run, delete test artifacts generated by the PowerShell scripts.
    """
    yield
    # Give external observers a brief window before cleanup kicks in
    time.sleep(20)
    patterns = [
        ROOT_DIR / "tests" / "results" / "*.crt",
        ROOT_DIR / "tests" / "results" / "*.csr",
        ROOT_DIR / "tests" / "results" / "*.key",
        ROOT_DIR / "tests" / "estclient" / "etx-estclient.*",
        ROOT_DIR / "tests" / "estclient" / "pikachu_issued_https_pkcs8.key",
    ]
    for pat in patterns:
        for path in pat.parent.glob(pat.name):
            try:
                path.unlink()
            except Exception:
                pass
    # DB cleanup: remove test certificates generated by API scripts
    try:
        cfg = configparser.ConfigParser()
        cfg.read(ROOT_DIR / "config.ini")
        db_rel = cfg.get("PATHS", "db_path", fallback="PKI.db")
        db_path = ROOT_DIR / db_rel
        if db_path.exists():
            patterns = [
                "%sscep-test-%",
                "%sscep-test-pass-%",
                "%estclient-go-%",
                "%estclient-go-mtls-%",
            ]
            with sqlite3.connect(db_path) as conn:
                for p in patterns:
                    conn.execute("DELETE FROM certificates WHERE subject LIKE ?", (p,))
                conn.commit()
    except Exception:
        pass


def _run_ps_script(script_name, args=(), timeout=240):
    script_path = SCRIPTS_DIR / script_name
    if not script_path.exists():
        pytest.skip(f"Script not found: {script_path}")
    cmd = [
        "powershell",
        "-ExecutionPolicy",
        "Bypass",
        "-File",
        str(script_path),
        *[str(a) for a in args],
    ]
    proc = subprocess.run(
        cmd,
        cwd=ROOT_DIR,
        capture_output=True,
        text=True,
        timeout=timeout,
    )
    return proc


def _combined_output(proc: subprocess.CompletedProcess) -> str:
    return (proc.stdout or "") + "\n" + (proc.stderr or "")


def _skip_if_missing_tool(proc: subprocess.CompletedProcess, keywords):
    # Only consider skipping when the script failed
    if proc.returncode == 0:
        return
    output = _combined_output(proc).lower()
    failure_markers = [
        "not recognized",
        "not found",
        "no such file",
        "could not find",
        "missing",
        "is not installed",
        "command not found",
    ]
    for kw in keywords:
        if kw.lower() in output:
            if any(marker in output for marker in failure_markers):
                pytest.skip(f"Missing prerequisite/tool: {kw}")


def _attach_output(request, name: str, proc: subprocess.CompletedProcess):
    """Attach script output to pytest-html report if plugin is present."""
    pytest_html = request.config.pluginmanager.getplugin("html")
    if not pytest_html:
        return
    extra = getattr(request.node, "extra", [])
    content = _combined_output(proc)
    extra.append(pytest_html.extras.text(content, name=name))
    request.node.extra = extra


def _emit_and_attach(request, name: str, proc: subprocess.CompletedProcess) -> str:
    """Print script output (for pytest-html logs) and attach as extra."""
    output = _combined_output(proc)
    print(f"\n--- {name} ---\n{output}\n--- end {name} ---\n")
    _attach_output(request, name, proc)
    return output


def test_api_basic_endpoints(request):
    """Run basic API checks (CA chain, CRL, status, CSR download)."""
    proc = _run_ps_script("test_basic.ps1", timeout=180)
    _emit_and_attach(request, "test_basic.ps1 output", proc)
    if proc.returncode != 0:
        pytest.fail(f"test_basic.ps1 failed:\n{_combined_output(proc)}")


def test_est_enrollment_via_estclient_go(request):
    """EST enrollment using estclient-go (non-mTLS)."""
    if not _is_enterprise():
        pytest.skip("EST is enterprise-only in community mode")
    proc = _run_ps_script("test_estclient_go.ps1", timeout=240)
    _skip_if_missing_tool(proc, ["estclient", "wsl"])
    _emit_and_attach(request, "test_estclient_go.ps1 output", proc)
    if proc.returncode != 0:
        pytest.fail(f"test_estclient_go.ps1 failed:\n{_combined_output(proc)}")


def test_est_enrollment_via_estclient_go_mtls(request):
    """EST enrollment using estclient-go with mTLS."""
    if not _is_enterprise():
        pytest.skip("EST mTLS is enterprise-only in community mode")
    proc = _run_ps_script("test_estclient_go_mtls.ps1", timeout=240)
    _skip_if_missing_tool(proc, ["estclient", "wsl"])
    _emit_and_attach(request, "test_estclient_go_mtls.ps1 output", proc)
    if proc.returncode != 0:
        pytest.fail(f"test_estclient_go_mtls.ps1 failed:\n{_combined_output(proc)}")


def test_sscep_core(request):
    """SCEP tests without challenge password (sscep.exe)."""
    if not _is_enterprise():
        pytest.skip("SCEP is enterprise-only in community mode")
    proc = _run_ps_script("test_sscep.ps1", timeout=180)
    _skip_if_missing_tool(proc, ["sscep.exe", "openssl"])
    _emit_and_attach(request, "test_sscep.ps1 output", proc)
    if proc.returncode != 0:
        pytest.fail(f"test_sscep.ps1 failed:\n{_combined_output(proc)}")


def _generate_challenge_password():
    cfg = configparser.ConfigParser()
    cfg.read(ROOT_DIR / "config.ini")
    http_port = cfg.get("DEFAULT", "http_port", fallback="80")
    challenge_enabled = cfg.getboolean("SCEP", "challenge_password_enabled", fallback=False)
    if not challenge_enabled:
        return ""
    token = cfg.get("DEFAULT", "tests_api_token", fallback="").strip()
    if not token:
        return "NO_TOKEN"

    base_url = f"http://127.0.0.1:{http_port}"
    try:
        resp = requests.post(
            f"{base_url}/api/challenge_passwords",
            headers={"Authorization": f"Bearer {token}"},
            timeout=20,
        )
    except Exception as e:
        return f"REQ_FAILED:{e}"

    if resp.status_code != 201:
        return f"API_FAILED:{resp.status_code}:{resp.text[:200]}"

    try:
        data = resp.json()
    except Exception:
        return "PARSE_FAILED"

    value = data.get("value")
    if not value:
        return "EMPTY_PASSWORD"
    return value


def test_sscep_with_challenge_password(request):
    """SCEP tests with challenge password (sscep.exe + challenge)."""
    if not _is_enterprise():
        pytest.skip("SCEP challenge password is enterprise-only in community mode")
    challenge = _generate_challenge_password()
    if not challenge or challenge.startswith(("LOGIN_FAILED", "GEN_FAILED", "DATA_FAILED", "NO_PASSWORDS", "EMPTY_PASSWORD", "PARSE_FAILED")):
        pytest.skip(f"Could not generate challenge password ({challenge})")
    proc = _run_ps_script("test_sscep_pass.ps1", args=[challenge], timeout=180)
    output = _emit_and_attach(request, "test_sscep_pass.ps1 output", proc)
    _skip_if_missing_tool(proc, ["sscep.exe", "openssl"])
    if proc.returncode != 0:
        pytest.fail(f"test_sscep_pass.ps1 failed:\n{output}")


def test_enterprise_endpoint_est_present(client):
    """Edition-aware check for EST endpoint."""
    resp = client.get("/.well-known/est/cacerts")
    if _is_enterprise():
        assert resp.status_code != 404, "EST endpoint is unavailable in enterprise mode"
    else:
        assert resp.status_code == 404, "EST endpoint should be blocked in community mode"


def test_enterprise_endpoint_scep_present(client):
    """Edition-aware check for SCEP endpoint."""
    resp = client.get("/scep?operation=GetCACaps")
    if _is_enterprise():
        assert resp.status_code != 404, "SCEP endpoint is unavailable in enterprise mode"
    else:
        assert resp.status_code == 404, "SCEP endpoint should be blocked in community mode"


def test_enterprise_endpoint_ocsp_present(client):
    """Edition-aware check for OCSP endpoint."""
    resp = client.get("/ocsp")
    if _is_enterprise():
        assert resp.status_code != 404, "OCSP endpoint is unavailable in enterprise mode"
    else:
        assert resp.status_code == 404, "OCSP endpoint should be blocked in community mode"
